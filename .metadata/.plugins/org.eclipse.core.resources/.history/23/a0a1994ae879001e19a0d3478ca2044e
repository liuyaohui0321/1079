#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"

#include "simple_dma.h"
#include "cmd.h"

#include "nhc_amba.h"
#include "mem_test.h"
#include "uart_get.h"
#include "xllfifo_drv.h"
#include "xstatus.h"

#include "fat/ff.h"		/* Declarations of FatFs API */
#include "fat/diskio.h"		/* Declarations of device I/O functions */
#include "fat/ffconf.h"
#include <wchar.h>
//#include "7x_dma.h"
#include "xil_io.h"
#include "xil_cache.h"
#include "time.h"
#include "check.h"

/********************文件系统格式化与挂载有关参数*******************/
static BYTE Buff[4096];  //与格式化空间大小有关
FATFS fs;
FIL fnew,fnew1;
FRESULT fr;
FILINFO fno;
FIL file;
/************************************************************/
u32 DestinationBuffer[MAX_DATA_BUFFER_SIZE * WORD_SIZE];
u32 DestinationBuffer_1[MAX_DATA_BUFFER_SIZE * WORD_SIZE];

int  Status;
char input_string[10];
uint fnum;
BYTE WriteBuffer[4096];
/********************读盘存盘数据参数*******************/
uint32_t  buff,buff_r;
uint32_t  buff1;
uint32_t  Checknum=0;
uint32_t  packnum;        // lyh 2023.8.28
uint64_t  slba=0;
uint64_t  slba_r=0;
uint32_t  cmd_len,len;
uint64_t  suba_r;
uint32_t  recv_cmd_ack;
uint64_t  write_slba = 0;
int read_flag=0;
uint32_t rw_count=0,r_count=0;
uint32_t  cmd_write_cnt=0;
/***************************************************/
//#define OFFSET_SIZE             2*1024*1024           // 娴嬭瘯2M      9.28 lyh
//#define OFFSET_SIZE             2*2*1024*1024         // 娴嬭瘯4M
//#define OFFSET_SIZE             2*2*2*1024*1024       // 娴嬭瘯8M
//#define OFFSET_SIZE             2*2*2*2*1024*1024     // 娴嬭瘯16M
#define OFFSET_SIZE             2*2*2*2*2*1024*1024   // 娴嬭瘯32M
//#define OFFSET_SIZE             2*2*2*2*2*2*1024*1024 // 娴嬭瘯64M
//#define OFFSET_SIZE             2*2*2*2*2*2*2*1024*1024 // 娴嬭瘯128M

int main()
{
		int ret;
		int i;
		int count;
		uint32_t  io_thr;
		uint32_t k=0;
		int bw,br;
		uint8_t cmd;
		uint8_t sts;
		init_platform();
		xil_printf("UCAS Prj1079 \r\n");
		DiskInit();
		SimpleDmaInit();        // 1x DMA0
		MsgQueryInit();         // Queue初始化
		XLLFIFO_SysInit();      // 7x 读盘存盘fifo
		Status = XAxiDma1_tx_rx(XPAR_AXIDMA_1_DEVICE_ID);
		if (Status != XST_SUCCESS) {
				xil_printf("XAxiDma Failed\r\n");
				return XST_FAILURE;
		}
//		for(int l=0;l<2048;l++)
//		{
//			Xil_Out8((UINTPTR)(0x80000000+l),0xDD);
//		}
//		for(int l=0;l<2048;l++)
//		{
//			Xil_Out8((UINTPTR)(0x80000800+l),0x11);
//		}
//		disk_write(0,(BYTE *)0x80000000,1,1);
//		disk_read(0,(BYTE *)0xE0000000,1,1);
////		Dma1Init();             // 7x DMA1 9.12 LYH
#if 0//format the filesysterm
		ret = f_mkfs(
			"",	/* Logical drive number */
			0,			/* Format option  FM_EXFAT*/
			Buff,			/* Pointer to working buffer (null: use heap memory) */
			sizeof Buff			/* Size of working buffer [byte] */
			);
		if (ret != FR_OK) {
			xil_printf("f_mkfs  Failed! ret=%d\n", ret);
			return 0;
			}
#endif //format the filesysterm

/********* mount filesysterm *********/
#if 0
		ret = f_mount (&fs, "", 1);
		if (ret != FR_OK) {
		xil_printf("f_mount  Failed! ret=%d\n", ret);
			return 0;
		}
		xil_printf(" Init All ok!\r\n");
#endif
////
////		Status = XAxiDma1_tx_rx(XPAR_AXIDMA_1_DEVICE_ID);
////		if (Status != XST_SUCCESS) {
////				xil_printf("XAxiDma Failed\r\n");
////				return XST_FAILURE;
////		}
////		//*********测试x7 2023.9.27 -a 加*********//
#if 0
		ret = f_open(&file, "B", FA_CREATE_ALWAYS | FA_WRITE |FA_READ);
		if (ret != FR_OK)
		{
			xil_printf("f_open Failed! ret=%d\r\n", ret);
			//cmd_reply_a203_to_a201(pMsg->PackNum,pMsg->HandType,pMsg->HandId,0x10);  // lyh 2023.8.15
			return ret;
		}
#endif
//		xil_printf(" Open ok!\r\n");

		xil_printf("[1] I/O Write Test.\r\n");           //LYH  2023.8.21
		xil_printf("[2] I/O Read  Test.\r\n");
		xil_printf("Command: \0");
#if 0   //10.16 LYH
		buff = (void *)(MEM_DDR3_BASE);
		while(1)
		{
//			for(i=0;i<NHC_NUM;i++)
//			{
//				io_monitor_clear(i);
//			}
			if(io_write(NHC_NUM,0x1,buff,slba,OFFSET_SIZE,0x0)!=0x2)
			{
				 xil_printf("I/O Write Failed!\r\n");
				 return 0;
			}
			slba+=OFFSET_SIZE;
			if (buff < (0x9F000000))
			{
				buff+=OFFSET_SIZE/2;
			}
			else
			{
				buff= MEM_DDR3_BASE;
			}
//			for(i=0;i<NHC_NUM;i++)
//			{
//				io_thr = io_monitor_wr(i,(1000*1000)/freq_MHz); // 250MHz: 4000ps
//				xil_printf("NHC%1d I/O Write Throughput = %d MB/s.\n\n", i,io_thr);
//			}
			count++;
		}
#endif

#if 01  //10.28 remodify   by LYH  (modified in 10.26) check success
		buff = (void *)(MEM_DDR3_BASE);
		while(1)
		{
			Xil_Out32((UINTPTR*)(0x80000000+4*k),k*4);
			k++;
			if(k==0x4000000)
			{
				break;
			}
		}
		for(int o=0;o<8;o++)
		{
			if(io_write2(NHC_NUM,0x1,buff,slba,OFFSET_SIZE,0x0)!=0x2)
			{
				 xil_printf("I/O Write Failed!\r\n");
				 return 0;
			}
			buff+=OFFSET_SIZE;
			slba+=OFFSET_SIZE;
		}


		buff_r = (void *)(MEM_DDR3_BASE+(3*512*1024*1024));
		xil_printf("Read Start\r\n");

		int len=0x800000;
		for(int o=0;o<32;o++)
		{
			if(io_read2(NHC_NUM,0x1,buff_r,slba_r,len,0x0)!=0x2)
			{
				 xil_printf("I/O Write Failed!\r\n");
				 return 0;
			}
			buff_r+=0x800000;
			slba_r+=0x800000;
		}

		buff_r = (void *)(MEM_DDR3_BASE+(3*512*1024*1024));
		uint32_t last=(void *)(0xF0000000);

		uint32_t check_block_size=0x100000;
		if(CheckOut_HeadTail((uint32_t *)buff_r,(uint32_t *)last,check_block_size)!=0)
		{
			xil_printf("check error!\r\n");
		}

		buff = (void *)(MEM_DDR3_BASE);
		buff_r = (void *)(MEM_DDR3_BASE+(3*512*1024*1024));
		if(CheckOutAll((uint32_t *)buff,(uint32_t *)buff_r,0x11000000)!=0)
		{
			xil_printf("check error!\r\n");
		}
		xil_printf("end!\r\n");

#endif


#if 0  //10.24 LYH
		buff = (void *)(MEM_DDR3_BASE);
//		while(1)
//		{
//			Xil_Out32((UINTPTR*)(0x80000000+4*k),k*4);
//			k++;
//			if(k==0x800000)
//			{
//				break;
//			}
//		}
		ret = f_open(&file, "J", FA_CREATE_ALWAYS | FA_WRITE |FA_READ);
		if (ret != FR_OK)
		{
			xil_printf("f_open Failed! ret=%d\r\n", ret);
			//cmd_reply_a203_to_a201(pMsg->PackNum,pMsg->HandType,pMsg->HandId,0x10);  // lyh 2023.8.15
			return ret;
		}
//		for(int o=0;o<10;o++)
//		{
			ret = f_write1 (&file, buff, 0x2000000, &bw);
			if (ret != FR_OK)
			{
				xil_printf("f_write Failed! ret=%d\r\n", ret);
				return ret;
			}
//			buff+=0x200000;
//		}

		buff_r = (void *)(MEM_DDR3_BASE+(3*512*1024*1024));
		f_close(&file);
		ret = f_open(&file, "J", FA_OPEN_EXISTING |FA_READ);
		if (ret != FR_OK)
		{
			xil_printf("f_open Failed! ret=%d\r\n", ret);
			//cmd_reply_a203_to_a201(pMsg->PackNum,pMsg->HandType,pMsg->HandId,0x10);  // lyh 2023.8.15
			return ret;
		}
//		for(int o=0;o<2;o++)
//		{
			ret = f_read (&file, buff_r, 0x2000000, &br);
			if (ret != FR_OK)
			{
				xil_printf("f_read Failed! ret=%d\r\n", ret);
				return ret;
			}
//			buff_r+=0x1000000;
//		}
		if(CheckOutAll((uint32_t *)buff,(uint32_t *)buff_r,0x2000000)!=0)
		{
			xil_printf("check error!\r\n");
		}
		xil_printf("end!\r\n");
//
//	     disk_write(BYTE pdrv, const BYTE* buff, LBA_t sector, UINT count);
#endif

#if 0  //10.19 LYH
		buff = (void *)(MEM_DDR3_BASE);
//		while(1)
//		{
//			Xil_Out32((UINTPTR*)(0x80000000+4*k),k*4);
//			k++;
//			if(k==0x800000)
//			{
//				break;
//			}
//		}
//		while(1)
//		{
//		for(int o=0;o<2;o++)
//		{

			if(io_write2(NHC_NUM,0x1,buff,slba,OFFSET_SIZE*2,0x0)!=0x2)
			{
				 xil_printf("I/O Write Failed!\r\n");
				 return 0;
			}
			slba+=0x2000000;
			buff+=0x800000;
			if(io_write2(NHC_NUM,0x1,buff,slba,OFFSET_SIZE*2,0x0)!=0x2)
			{
				 xil_printf("I/O Write Failed!\r\n");
				 return 0;
			}
//			slba+=OFFSET_SIZE;
//			if (buff < (0x9F000000))
//			{
//				buff+=OFFSET_SIZE;
//			}
//			else
//			{
//				buff= MEM_DDR3_BASE;
//			}
//			count++;
//		}
//		}

#endif
		mygets(input_string);
		cmd = strtoul(input_string, NULL, 0);
		buff = (void *)(MEM_DDR3_BASE);
		buff1 = (void *)(MEM_DDR3_BASE);
		buff_r = (void *)(MEM_DDR3_BASE+(3*512*1024*1024));
		xil_printf("Waiting FPGA Vio Ctrl Read Write Start\r\n");
#if   0   //lyh 10.25
		int len=0x400000;
//		for(int o=0;o<2;o++)
//		{
			if(io_read(NHC_NUM,0x1,buff_r,slba_r,len*2,0x0)!=0x2)
			{
				 xil_printf("I/O Write Failed!\r\n");
				 return 0;
			}
			buff_r+=0x400000;
			slba_r+=0x1000000;
			if(io_read(NHC_NUM,0x1,buff_r,slba_r,len*2,0x0)!=0x2)
			{
				 xil_printf("I/O Write Failed!\r\n");
				 return 0;
			}
			buff_r+=0x400000;
			slba_r+=0x1000000;
			if(io_read(NHC_NUM,0x1,buff_r,slba_r,len*2,0x0)!=0x2)
			{
				 xil_printf("I/O Write Failed!\r\n");
				 return 0;
			}
			buff_r+=0x400000;
			slba_r+=0x1000000;
			if(io_read(NHC_NUM,0x1,buff_r,slba_r,len*2,0x0)!=0x2)
			{
				 xil_printf("I/O Write Failed!\r\n");
				 return 0;
			}
			buff_r = (void *)(MEM_DDR3_BASE+(3*512*1024*1024));

			if(CheckOutAll((uint32_t *)buff,(uint32_t *)buff_r,0x3000000)!=0)
			{
				xil_printf("check error!\r\n");
			}

//			buff_r+=len;
//			slba_r += len;
//			if(io_read(NHC_NUM,0x1,buff_r,slba_r,len*2,0x0)!=0x2)
//			{
//				 xil_printf("I/O Write Failed!\r\n");
//				 return 0;
//			}
//		}
			xil_printf("end!\r\n");
#endif
#if 1
		while ((0x2==cmd)||(0x1==cmd))
		{
			if (0x1==cmd)
			{
				if (RxReceive(DestinationBuffer,&cmd_len) == XST_SUCCESS)
				{
					packnum =DestinationBuffer[0];
					buff =DestinationBuffer[1];
					len  =DestinationBuffer[2];
//					read_flag=1;
					buff1=(buff<0x90000000?MEM_DDR3_BASE:0x90000000);
					if (io_write2(NHC_NUM,0x1,(buff-buff1)*2+MEM_DDR3_BASE, slba, len, 0x0) != 0x02)
					{
						 xil_printf("I/O Write Failed!\r\n");
						 return 0;
					}
//					 xil_printf("buff:0x%lx slba:0x%llx\r\n",(buff-buff1)*2+MEM_DDR3_BASE,slba);
					 slba += len;
					 cmd_write_cnt += 1;
				}
				else
				{

					for(i=0;i<NHC_NUM;i++)
					{
						do {
							sts = nhc_cmd_sts(i);
							}while(sts == 0x01);
					}
				}
			}
			if (0x2==cmd)
			{
				if(io_read(NHC_NUM, 0x1, buff_r, slba_r, OFFSET_SIZE, 0x0) != 0x02)
				{
					xil_printf("I/O Read Failed!\r\n");
				}

				uint32_t last=(void *)(0xE2000000);
				uint32_t check_block_size=0x200000;

				if(CheckOut_HeadTail((uint32_t *)buff_r,(uint32_t *)last,check_block_size)!=0)
				{
					xil_printf("check error!\r\n");
					return 1;
				}
				Checknum++;
				xil_printf("Checknum:%d\r\n",Checknum);
//				xil_printf("buff_r:0x%lx slba_r:0x%llx\r\n",buff_r,slba_r);
				slba_r += OFFSET_SIZE;
//				if (buff_r <(DDR3_END_ADDR-OFFSET_SIZE))
//					buff_r += OFFSET_SIZE;
//				else
//					buff_r = MEM_DDR3_BASE+(512*3*1024*1024);
//				do
//				{
//					DestinationBuffer_1[0]=0;
//					RxReceive_1(DestinationBuffer_1,&cmd_len);
//
//				}	while(!(0xaa55aa55 == DestinationBuffer_1[0]));
				recv_cmd_ack = recv_cmd_ack + 1;
				r_count++;
			}
			for(i=0;i<NHC_NUM;i++)
			{
				while (nhc_queue_ept(i) == 0)
				{
					do {
						sts = nhc_cmd_sts(i);
					}while(sts == 0x01);
				}
			}
			if(r_count>7||cmd_write_cnt>7)
			{
				xil_printf("I/O Read or Write Test Finish!\r\n");
				xil_printf("w_count = %u   r_count=%u\r\n",cmd_write_cnt,r_count);
				for(i=0;i<NHC_NUM;i++)
				{
					while (nhc_queue_ept(i) == 0)
					{
						do {
							sts = nhc_cmd_sts(i);
						}while(sts == 0x01);
					}
				}
				cmd_write_cnt=0;
				cmd=2;       // 2023.8.21
			}
		}// while
//			f_close(&file);
		    cleanup_platform();
			return 0;
}
#endif

#if 0
		while ((0x2==cmd)||(0x1==cmd))
		{
				if (0x1==cmd)
				{
						if (RxReceive(DestinationBuffer,&cmd_len) == XST_SUCCESS)
						{
							packnum =DestinationBuffer[0];
							buff =DestinationBuffer[1];  // 保存写入数据的DDR地址
							len  =DestinationBuffer[2];  // 写入数据的长度
							cmd_write_cnt += 1;
//							if(cmd_write_cnt%50==0)
//							{
//								xil_printf("%x %x %x\r\n",buff,len,cmd_write_cnt);
//							}
							ret = f_write1(
								&file,			/* Open file to be written */
								buff,			/* Data to be written */
								len,			/* Number of bytes to write */
								&bw				/* Number of bytes written */
							);
							if (ret != FR_OK)
							{
								 xil_printf(" f_write Failed! %d\r\n",ret);
								 f_close(&file);
								 //cmd_reply_a203_to_a201(pMsg->PackNum,pMsg->HandType,pMsg->HandId,0x10);  // lyh 2023.8.15
								 return ret;
							}

						}   // if
						else
						{
							for(i=0;i<NHC_NUM;i++)
							{
								do {
										sts = nhc_cmd_sts(i);
									}while(sts == 0x01);
							}
						}

			 }
			 if (0x2==cmd)
			 {
				 if(r_count==0)
				 {
					 	f_close(&file);
//					    f_sync(&file);
				        ret = f_open(&file, "B", FA_OPEN_EXISTING |FA_READ);
//					    ret = f_lseek(&file,0);
						if (ret != FR_OK)
						{
							xil_printf("f_open Failed! ret=%d\r\n", ret);
							//cmd_reply_a203_to_a201(pMsg->PackNum,pMsg->HandType,pMsg->HandId,0x10);  // lyh 2023.8.15
							return ret;
						}
				 }
						len= OFFSET_SIZE;
						ret = f_read1(
										&file,			/* Open file to be written */
										buff_r,			/* Data to be written */
										len,			/* Number of bytes to write */
										&bw				/* Number of bytes written */
						);
						if (ret != FR_OK)
						{
							 xil_printf("f_read Failed! ret=%d\r\n", ret);
							 return ret;
						}
						recv_cmd_ack = recv_cmd_ack + 1;
						r_count++;
						if (buff_r < (DDR3_END_ADDR-OFFSET_SIZE))
							buff_r += OFFSET_SIZE;
						else
							buff_r = MEM_DDR3_BASE+(512*3*1024*1024);

			}
			for(i=0;i<NHC_NUM;i++)
			{
				while (nhc_queue_ept(i) == 0)
				{
					do {
						sts = nhc_cmd_sts(i);
					}while(sts == 0x01);
				}
			}
	//	    if(r_count>1||cmd_write_cnt>100)
//			if(r_count>250||cmd_write_cnt>10)
			if(r_count>250||cmd_write_cnt>340)
			{
				xil_printf("I/O Read or Write Test Finish!\r\n");
				xil_printf("w_count = %u   r_count=%u\r\n",cmd_write_cnt,r_count);
				for(i=0;i<NHC_NUM;i++)
				{
					while (nhc_queue_ept(i) == 0)
					{
						do {
							sts = nhc_cmd_sts(i);
						}while(sts == 0x01);
					}
				}
//				f_close(&file);
				if(r_count>250)
				{
					r_count=0;
					return 0;
				}
				cmd_write_cnt=0;
				cmd=2;       // 2023.8.21
			}
		}// while
			f_close(&file);
		    cleanup_platform();
			return 0;
		//**************************************//

}
#endif

#if 0
	#if 1 //recv
		while(1)
		{
			GetMessage(&CurMsg);

			switch(CurMsg.HandType)
			{
    				case 0XA2:
    					xil_printf("%s %d\r\n", __FUNCTION__, __LINE__);
    					switch( CurMsg.HandId)
    					{
    						case 0x1:
    							xil_printf("%s %d  CurMsg.HandType:0x%x CurMsg.HandId:0x%x\r\n", __FUNCTION__, __LINE__,CurMsg.HandType,CurMsg.HandId);
    							run_cmd_a201(&CurMsg);
    						break;
    						case 0x2:
    							xil_printf("%s %d  CurMsg.HandType:0x%x CurMsg.HandId:0x%x\r\n", __FUNCTION__, __LINE__,CurMsg.HandType,CurMsg.HandId);
    							run_cmd_a202(&CurMsg);
    						break;
    						case 0x4:
    							xil_printf("%s %d  CurMsg.HandType:0x%x CurMsg.HandId:0x%x\r\n", __FUNCTION__, __LINE__,CurMsg.HandType,CurMsg.HandId);
    							run_cmd_a204(&CurMsg);
    						break;
    						case 0x5:
    							xil_printf("%s %d  CurMsg.HandType:0x%x CurMsg.HandId:0x%x\r\n", __FUNCTION__, __LINE__,CurMsg.HandType,CurMsg.HandId);
    							run_cmd_a205(&CurMsg);
    						break;
    						default:
    						break;
    					}
    					break;
    				case 0XB2:
    					xil_printf("%s %d  CurMsg.HandType:0x%x\r\n", __FUNCTION__, __LINE__,CurMsg.HandType);
    					run_cmd_b201(&CurMsg);
    					break;
    				case 0XD2:
    					xil_printf("%s %d\r\n", __FUNCTION__, __LINE__);
    					switch( CurMsg.HandId)
    					{
    						case 0x1:
    							xil_printf("%s %d  CurMsg.HandType:0x%x CurMsg.HandId:0x%x\r\n", __FUNCTION__, __LINE__,CurMsg.HandType,CurMsg.HandId);
    							run_cmd_d201(&CurMsg);
    						break;
//    						case 0x2:
//    							xil_printf("%s %d  CurMsg.HandType:0x%x CurMsg.HandId:0x%x\r\n", __FUNCTION__, __LINE__,CurMsg.HandType,CurMsg.HandId);
//    							run_cmd_d202(&CurMsg);
//    						break;
    						case 0x3:
    							xil_printf("%s %d  CurMsg.HandType:0x%x CurMsg.HandId:0x%x\r\n", __FUNCTION__, __LINE__,CurMsg.HandType,CurMsg.HandId);
//    							run_cmd_d203(&CurMsg);
    						break;
//    						case 0x4:
//    							xil_printf("%s %d  CurMsg.HandType:0x%x CurMsg.HandId:0x%x\r\n", __FUNCTION__, __LINE__,CurMsg.HandType,CurMsg.HandId);
//    							run_cmd_d204(&CurMsg);
//    						break;
    						case 0x5:
    							xil_printf("%s %d  CurMsg.HandType:0x%x CurMsg.HandId:0x%x\r\n", __FUNCTION__, __LINE__,CurMsg.HandType,CurMsg.HandId);
    							run_cmd_d205(&CurMsg);
    						break;
//    						case 0x6:
//    							xil_printf("%s %d  CurMsg.HandType:0x%x CurMsg.HandId:0x%x\r\n", __FUNCTION__, __LINE__,CurMsg.HandType,CurMsg.HandId);
//    							run_cmd_d206(&CurMsg);
//    						break;
    						case 0x7:
    							xil_printf("%s %d  CurMsg.HandType:0x%x CurMsg.HandId:0x%x\r\n", __FUNCTION__, __LINE__,CurMsg.HandType,CurMsg.HandId);
    							run_reply_d207(&CurMsg);
    						break;
    						case 0x8:
    							xil_printf("%s %d  CurMsg.HandType:0x%x CurMsg.HandId:0x%x\r\n", __FUNCTION__, __LINE__,CurMsg.HandType,CurMsg.HandId);
    							run_reply_d208(&CurMsg);
    						break;
    						default:
    						break;
    					}
    					break;

    				default:
    					break;
			}

//			ret = f_mount (NULL, "", 1);
//			if (ret != FR_OK)
//			{
//				xil_printf("f_mount  Failed! ret=%d\n", ret);
//				return 0;
//			}
    }
#endif  //recv
    cleanup_platform();
    return 0;

}
#endif



