
#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"

#include "simple_dma.h"
#include "cmd.h"

#include "nhc_amba.h"
#include "mem_test.h"
#include "uart_get.h"
#include "xllfifo_drv.h"
#include "xstatus.h"

#include "fat/ff.h"		/* Declarations of FatFs API */
#include "fat/diskio.h"		/* Declarations of device I/O functions */
#include "fat/ffconf.h"
#include <wchar.h>
u32 DestinationBuffer[MAX_DATA_BUFFER_SIZE * WORD_SIZE];
u32 DestinationBuffer_1[MAX_DATA_BUFFER_SIZE * WORD_SIZE];
uint32_t  cmd_write_cnt = 0;

uint8_t   init_done = 0x0;
uint32_t  freq_MHz = 250;
char     input_string[10];
uint32_t  timeout_sec;

static BYTE Buff[4096];
uint32_t fori;
FATFS fs;
FIL fnew,fnew1;
uint fnum;
BYTE WriteBuffer[4096];
FRESULT fr;
FILINFO fno;



void DiskInit(void);


int main()
{
	int ret;
	init_platform();
    xil_printf("UCAS Prj1079 by wfeng\r\n");

    DiskInit();
    SimpleDmaInit();
	MsgQueryInit();

	/*** mount filesysterm ***/
	ret = f_mount (&fs, " ", 1);
	if (ret != FR_OK) {
    xil_printf("f_mount  Failed! ret=%d\n", ret);
		return 0;
	}

    xil_printf(" Init All ok!\r\n");

#if 1 //recv
    while(1)
    {
    	GetMessage(&CurMsg);

    	switch(CurMsg.HandType)
    			{
    				case 0XA2:
    					xil_printf("%s %d\r\n", __FUNCTION__, __LINE__);
    					switch( CurMsg.HandId)
    					{
    						case 0x1:
    							xil_printf("%s %d  CurMsg.HandType:0x%x CurMsg.HandId:0x%x\r\n", __FUNCTION__, __LINE__,CurMsg.HandType,CurMsg.HandId);
    							run_cmd_a201(&CurMsg);
    						break;
    						case 0x2:
    							run_cmd_a202(&CurMsg);
    						break;
    						case 0x4:
    							run_cmd_a204(&CurMsg);
    						break;
    						case 0x5:
    							run_cmd_a205(&CurMsg);
    						break;
    						default:
    						break;
    					}
    					break;
    				case 0XB2:
    					run_cmd_b201(&CurMsg);
    					break;
    				case 0XD2:
    					switch( CurMsg.HandId)
    					{
    						case 0x1:
    							run_cmd_d201(&CurMsg);
    						break;
    						case 0x2:
    							run_cmd_d202(&CurMsg);
    						break;
    						case 0x3:
    							run_cmd_d203(&CurMsg);
    						break;
    						case 0x4:
    							run_cmd_d204(&CurMsg);
    						break;
    						case 0x5:
    							run_cmd_d205(&CurMsg);
    						break;
    						case 0x6:
    							run_cmd_d206(&CurMsg);
    						break;
    						case 0x7:
    							run_cmd_d207(&CurMsg);
    						break;
    						case 0x8:
    							run_cmd_d208(&CurMsg);
    						break;
    						default:
    						break;
    					}
    					break;

    				default:
    					break;
    			}

    }
#endif  //recv






#if 0  //fs test

	#if 1//format the filesysterm
    	ret = f_mkfs(
    		" ",	/* Logical drive number */
			0,			/* Format option  FM_EXFAT*/
			Buff,			/* Pointer to working buffer (null: use heap memory) */
			sizeof Buff			/* Size of working buffer [byte] */
    		);
    	if (ret != FR_OK) {
    		xil_printf("f_mkfs  Failed! ret=%d\n", ret);
    		return 0;
    		}
	#endif//format the filesysterm

	#if 1    //f_mount the filesysterm
    	ret = f_mount (
   		&fs,			/* Pointer to the filesystem object (NULL:unmount)*/
		" ",	/* Logical drive number to be mounted/unmounted */
   		1			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
    	);
    	if (ret != FR_OK) {
	    xil_printf("f_mount  Failed! ret=%d\n", ret);
   		return 0;
    	}
    	xil_printf("f_mount  ok!......\n");
	#endif   //f_mount the filesysterm

	#if 1  //f_mkdir
	ret =f_mkdir("payload");
	   if (ret != FR_OK) {
	    xil_printf("f_mkdir  Failed! ret=%d\n", ret);
   		return -1;
	   }
	   xil_printf("f_mkdir ok!....... ");
	#endif//f_mkdir

	#if 1   //f_open&write
	   ret =f_open(&fnew, "payload/wfeng.txt", FA_CREATE_ALWAYS | FA_WRITE );
	   if (ret != FR_OK) {
	    xil_printf("f_open  Failed! ret=%d\n", ret);
   		return -1;
	   }
	   xil_printf("f_open ok!..........\n");
	   
	   xil_printf("START f_WRITE 10MB DATA!.........\n");
	   memset((BYTE *)(0x80000000),7,1048576*10);
	   ret =f_write(&fnew,(BYTE *)(0x80000000),1048576*10,&fnum);
	   if (ret != FR_OK) {
	    xil_printf("f_write  Failed! ret=%d\n", ret);
   		return -1;
	   }
	   xil_printf("END f_write 10MB DATA!,fnum = %d",fnum);

	    f_close(&fnew);
	#endif //f_open&write

#endif  //fs test

    cleanup_platform();
    return 0;
}

void DiskInit()
{
	uint8_t   i;
	//xil_printf("Configure Timeout Value in second (HEX-0x?): \0");
	//mygets(input_string);
	//timeout_sec = strtoul(input_string, NULL, 0);
	timeout_sec = 1;
    xil_printf("NVMe Host IP Core Initialization Starts....\n");

    for(i=0;i<NHC_NUM;i++)
    {
		if(nhc_init(i,timeout_sec, freq_MHz) == 0x1) // 250MHz
		{
			xil_printf("NVMe Host IP Core #%1d Initialization Completes.\n\n",i);
		}
		else
		{
			xil_printf("NVMe Host IP Core #%1d Initialization Failed!\n\n",i);
		}
    }
    // ---------------------------------------------------------------------------
    // NHC Queue Configuration: 64-nodes depth and User mode
    // ---------------------------------------------------------------------------
    xil_printf("User Command Queue Configuration Starts....\n");
    for(i=0;i<NHC_NUM;i++)
    {
		if(nhc_queue_init(i,63, 0) == 0x1)
		{
			xil_printf("Core #%1d User Command Queue Configuration Completes.\n\n",i);
		}
		else
		{
			xil_printf("Core #%1d User Command Queue Configuration Failed!\n\n",i);
		}
    }
    // ---------------------------------------------------------------------------
    // NHC Startup
    // ---------------------------------------------------------------------------
    xil_printf("NHC Startup Starts(Identification, I/O Queue, ...)....\n");
    for(i=0;i<NHC_NUM;i++)
    {
		if(adm_startup(i) == 0x2)
		{
			xil_printf("NHC%1d Startup Completes.\n\n",i);
		}
		else
		{
			xil_printf("NHC%1d Startup Failed!\n\n",i);
		}
    }

    init_done = 0xFF;
    for(i=0;i<NHC_NUM;i++)
    {
    	io_monitor_enable(i);
    }

}

