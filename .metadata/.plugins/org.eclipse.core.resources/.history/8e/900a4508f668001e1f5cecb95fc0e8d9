#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"

#include "simple_dma.h"
#include "cmd.h"

#include "nhc_amba.h"
#include "mem_test.h"
#include "uart_get.h"
#include "xllfifo_drv.h"
#include "xstatus.h"

#include "fat/ff.h"		/* Declarations of FatFs API */
#include "fat/diskio.h"		/* Declarations of device I/O functions */
#include "fat/ffconf.h"
#include <wchar.h>
//#include "7x_dma.h"
#include "xil_io.h"
#include "xil_cache.h"
/**********************NVME控制器参数设置*************************/
uint8_t   init_done = 0x0;
uint32_t  freq_MHz = 250;
uint32_t  timeout_sec;
/************************************************************/

/********************文件系统格式化与挂载有关参数*******************/
static BYTE Buff[4096];  //与格式化空间大小有关
FATFS fs;
FIL fnew,fnew1;
FRESULT fr;
FILINFO fno;
FIL file;
/************************************************************/
u32 DestinationBuffer[MAX_DATA_BUFFER_SIZE * WORD_SIZE];
u32 DestinationBuffer_1[MAX_DATA_BUFFER_SIZE * WORD_SIZE];

int  Status;
char input_string[10];
uint fnum;
BYTE WriteBuffer[4096];
/********************读盘存盘数据参数*******************/
uint32_t  buff,buff_r;
uint32_t  packnum;        // lyh 2023.8.28
uint64_t  slba=0;
uint64_t  slba_r=0;
uint32_t  cmd_len,len;
uint64_t  suba_r;
uint32_t  recv_cmd_ack;
uint64_t  write_slba = 0;
int read_flag=0;
uint32_t rw_count=0,r_count=0;
uint32_t  cmd_write_cnt=0;
/***************************************************/
#define OFFSET_SIZE             2*1024*1024           // 娴嬭瘯2M      9.28 lyh
//#define OFFSET_SIZE             2*2*1024*1024         // 娴嬭瘯4M
//#define OFFSET_SIZE             2*2*2*1024*1024       // 娴嬭瘯8M
//#define OFFSET_SIZE             2*2*2*2*1024*1024     // 娴嬭瘯16M
//#define OFFSET_SIZE             2*2*2*2*2*1024*1024   // 娴嬭瘯32M
//#define OFFSET_SIZE             2*2*2*2*2*2*1024*1024 // 娴嬭瘯64M
void DiskInit(void);
int main()
{
		int ret;
		int i;
		int bw;
		uint8_t cmd;
		uint8_t sts;
		init_platform();
		xil_printf("UCAS Prj1079 \r\n");
		DiskInit();
		SimpleDmaInit();        // 1x DMA0
		MsgQueryInit();         // Queue初始化
		XLLFIFO_SysInit();      // 7x 读盘存盘fifo
		Status = XAxiDma1_tx_rx(XPAR_AXIDMA_1_DEVICE_ID);
		if (Status != XST_SUCCESS) {
				xil_printf("XAxiDma Failed\r\n");
				return XST_FAILURE;
		}
		for(int l=0;l<2048;l++)
		{
			Xil_Out8((UINTPTR)(0x80000000+l),0xCC);
		}
		for(int l=0;l<2048;l++)
		{
			Xil_Out8((UINTPTR)(0x80000800+l),0x33);
		}
		disk_write(0,(BYTE *)0x80000000,0,1);
		disk_read(0,(BYTE *)0xA0000000,0,1);
////		Dma1Init();             // 7x DMA1 9.12 LYH
#if 0//format the filesysterm
		ret = f_mkfs(
			"",	/* Logical drive number */
			0,			/* Format option  FM_EXFAT*/
			Buff,			/* Pointer to working buffer (null: use heap memory) */
			sizeof Buff			/* Size of working buffer [byte] */
			);
		if (ret != FR_OK) {
			xil_printf("f_mkfs  Failed! ret=%d\n", ret);
			return 0;
			}
#endif //format the filesysterm

/********* mount filesysterm *********/
#if 0
		ret = f_mount (&fs, " ", 1);
		if (ret != FR_OK) {
		xil_printf("f_mount  Failed! ret=%d\n", ret);
			return 0;
		}
		xil_printf(" Init All ok!\r\n");
#endif
////
////		Status = XAxiDma1_tx_rx(XPAR_AXIDMA_1_DEVICE_ID);
////		if (Status != XST_SUCCESS) {
////				xil_printf("XAxiDma Failed\r\n");
////				return XST_FAILURE;
////		}
////		//*********测试x7 2023.9.27 -a 加*********//
#if 0
		ret = f_open(&file, "L", FA_CREATE_ALWAYS | FA_WRITE |FA_READ);
		if (ret != FR_OK)
		{
			xil_printf("f_open Failed! ret=%d\r\n", ret);
			//cmd_reply_a203_to_a201(pMsg->PackNum,pMsg->HandType,pMsg->HandId,0x10);  // lyh 2023.8.15
			return ret;
		}
#endif
		xil_printf(" Open ok!\r\n");

		xil_printf("[1] I/O Write Test.\r\n");           //LYH  2023.8.21
		xil_printf("[2] I/O Read  Test.\r\n");
		xil_printf("Command: \0");
		mygets(input_string);
		cmd = strtoul(input_string, NULL, 0);
		buff_r = (void *)(MEM_DDR3_BASE+(3*512*1024*1024));
		xil_printf("Waiting FPGA Vio Ctrl Read Write Start\r\n");

#if 1
		while ((0x2==cmd)||(0x1==cmd))
		{
	//			sync_window
				if (0x1==cmd)
				{
						if (RxReceive(DestinationBuffer,&cmd_len) == XST_SUCCESS)
						{
	//						Xil_L1DCacheFlush(); // 9.26 锟斤拷
							packnum =DestinationBuffer[0];
							buff =DestinationBuffer[1];  // 保存写入数据的DDR地址
							len  =DestinationBuffer[2];  // 写入数据的长度
							cmd_write_cnt += 1;
							ret = f_write(
								&file,			/* Open file to be written */
								buff,			/* Data to be written */
								len,			/* Number of bytes to write */
								&bw				/* Number of bytes written */
							);
							if (ret != FR_OK)
							{
								 xil_printf(" f_write Failed! %d\r\n",ret);
								 f_close(&file);
								 //cmd_reply_a203_to_a201(pMsg->PackNum,pMsg->HandType,pMsg->HandId,0x10);  // lyh 2023.8.15
								 return ret;
							}

						}   // if
						else
						{
							for(i=0;i<NHC_NUM;i++)
							{
								do {
										sts = nhc_cmd_sts(i);
									}while(sts == 0x01);
							}
						}

			 }
			 if (0x2==cmd)
			 {
						len= OFFSET_SIZE;
						ret = f_read1(
										&file,			/* Open file to be written */
										buff_r,			/* Data to be written */
										len,			/* Number of bytes to write */
										&bw				/* Number of bytes written */
						);
						if (ret != FR_OK)
						{
							 xil_printf("f_read Failed! ret=%d\r\n", ret);
							 return ret;
						}
						recv_cmd_ack = recv_cmd_ack + 1;
						r_count++;
			}
			for(i=0;i<NHC_NUM;i++)
			{
				while (nhc_queue_ept(i) == 0)
				{
					do {
						sts = nhc_cmd_sts(i);
					}while(sts == 0x01);
				}
			}
	//	    if(r_count>1||cmd_write_cnt>100)
			if(r_count>250||cmd_write_cnt>10)
			{
				xil_printf("I/O Read or Write Test Finish!\r\n");
				xil_printf("w_count = %u   r_count=%u\r\n",cmd_write_cnt,r_count);
				for(i=0;i<NHC_NUM;i++)
				{
					while (nhc_queue_ept(i) == 0)
					{
						do {
							sts = nhc_cmd_sts(i);
						}while(sts == 0x01);
					}
				}
//				f_close(&file);
				if(r_count>250)
				{
					r_count=0;
					return 0;
				}
				cmd_write_cnt=0;
				cmd=2;       // 2023.8.21
			}
		}// while
//		while ((0x2==cmd)||(0x1==cmd))
//		{
////			sync_window
//			if (0x1==cmd)
//			{
//					if (RxReceive(DestinationBuffer,&cmd_len) == XST_SUCCESS)
//					{
////						Xil_L1DCacheFlush(); // 9.26 锟斤拷
//						packnum =DestinationBuffer[0];
//						buff =DestinationBuffer[1];  // 保存写入数据的DDR地址
//						len  =DestinationBuffer[2];  // 写入数据的长度
//						cmd_write_cnt += 1;
//						ret = f_write(
//							&file,			/* Open file to be written */
//							buff,			/* Data to be written */
//							len,			/* Number of bytes to write */
//							&bw				/* Number of bytes written */
//						);
//						if (ret != FR_OK)
//						{
//							 xil_printf(" f_write Failed! %d\r\n",ret);
//							 f_close(&file);
//							 //cmd_reply_a203_to_a201(pMsg->PackNum,pMsg->HandType,pMsg->HandId,0x10);  // lyh 2023.8.15
//							 return ret;
//						}
//
//					}   // if
//					else
//					{
//						for(i=0;i<NHC_NUM;i++)
//						{
//							do {
//									sts = nhc_cmd_sts(i);
//								}while(sts == 0x01);
//						}
//					}
//
//		 }
//		 if (0x2==cmd)
//		 {
//					len= OFFSET_SIZE;
//					ret = f_read1(
//									&file,			/* Open file to be written */
//									buff_r,			/* Data to be written */
//									len,			/* Number of bytes to write */
//									&bw				/* Number of bytes written */
//					);
//					if (ret != FR_OK)
//					{
//						 xil_printf("f_read Failed! ret=%d\r\n", ret);
//						 return ret;
//					}
//					recv_cmd_ack = recv_cmd_ack + 1;
//					r_count++;
//		}
//		for(i=0;i<NHC_NUM;i++)
//		{
//			while (nhc_queue_ept(i) == 0)
//			{
//				do {
//					sts = nhc_cmd_sts(i);
//				}while(sts == 0x01);
//			}
//		}
////	    if(r_count>1||cmd_write_cnt>100)
//		if(r_count>250)
//		{
//			xil_printf("I/O Read or Write Test Finish!\r\n");
//			xil_printf("w_count = %u   r_count=%u\r\n",cmd_write_cnt,r_count);
//			r_count=0;
//			for(i=0;i<NHC_NUM;i++)
//			{
//				while (nhc_queue_ept(i) == 0)
//				{
//					do {
//						sts = nhc_cmd_sts(i);
//					}while(sts == 0x01);
//				}
//			}
//			f_close(&file);
//			return 0;       // 2023.8.21
//		}
//	}// while
			f_close(&file);
		    cleanup_platform();
			return 0;
		//**************************************//
#endif
}


#if 0
	#if 1 //recv
		while(1)
		{
			GetMessage(&CurMsg);

			switch(CurMsg.HandType)
			{
    				case 0XA2:
    					xil_printf("%s %d\r\n", __FUNCTION__, __LINE__);
    					switch( CurMsg.HandId)
    					{
    						case 0x1:
    							xil_printf("%s %d  CurMsg.HandType:0x%x CurMsg.HandId:0x%x\r\n", __FUNCTION__, __LINE__,CurMsg.HandType,CurMsg.HandId);
    							run_cmd_a201(&CurMsg);
    						break;
    						case 0x2:
    							xil_printf("%s %d  CurMsg.HandType:0x%x CurMsg.HandId:0x%x\r\n", __FUNCTION__, __LINE__,CurMsg.HandType,CurMsg.HandId);
    							run_cmd_a202(&CurMsg);
    						break;
    						case 0x4:
    							xil_printf("%s %d  CurMsg.HandType:0x%x CurMsg.HandId:0x%x\r\n", __FUNCTION__, __LINE__,CurMsg.HandType,CurMsg.HandId);
    							run_cmd_a204(&CurMsg);
    						break;
    						case 0x5:
    							xil_printf("%s %d  CurMsg.HandType:0x%x CurMsg.HandId:0x%x\r\n", __FUNCTION__, __LINE__,CurMsg.HandType,CurMsg.HandId);
    							run_cmd_a205(&CurMsg);
    						break;
    						default:
    						break;
    					}
    					break;
    				case 0XB2:
    					xil_printf("%s %d  CurMsg.HandType:0x%x\r\n", __FUNCTION__, __LINE__,CurMsg.HandType);
    					run_cmd_b201(&CurMsg);
    					break;
    				case 0XD2:
    					xil_printf("%s %d\r\n", __FUNCTION__, __LINE__);
    					switch( CurMsg.HandId)
    					{
    						case 0x1:
    							xil_printf("%s %d  CurMsg.HandType:0x%x CurMsg.HandId:0x%x\r\n", __FUNCTION__, __LINE__,CurMsg.HandType,CurMsg.HandId);
    							run_cmd_d201(&CurMsg);
    						break;
//    						case 0x2:
//    							xil_printf("%s %d  CurMsg.HandType:0x%x CurMsg.HandId:0x%x\r\n", __FUNCTION__, __LINE__,CurMsg.HandType,CurMsg.HandId);
//    							run_cmd_d202(&CurMsg);
//    						break;
    						case 0x3:
    							xil_printf("%s %d  CurMsg.HandType:0x%x CurMsg.HandId:0x%x\r\n", __FUNCTION__, __LINE__,CurMsg.HandType,CurMsg.HandId);
//    							run_cmd_d203(&CurMsg);
    						break;
//    						case 0x4:
//    							xil_printf("%s %d  CurMsg.HandType:0x%x CurMsg.HandId:0x%x\r\n", __FUNCTION__, __LINE__,CurMsg.HandType,CurMsg.HandId);
//    							run_cmd_d204(&CurMsg);
//    						break;
    						case 0x5:
    							xil_printf("%s %d  CurMsg.HandType:0x%x CurMsg.HandId:0x%x\r\n", __FUNCTION__, __LINE__,CurMsg.HandType,CurMsg.HandId);
    							run_cmd_d205(&CurMsg);
    						break;
//    						case 0x6:
//    							xil_printf("%s %d  CurMsg.HandType:0x%x CurMsg.HandId:0x%x\r\n", __FUNCTION__, __LINE__,CurMsg.HandType,CurMsg.HandId);
//    							run_cmd_d206(&CurMsg);
//    						break;
    						case 0x7:
    							xil_printf("%s %d  CurMsg.HandType:0x%x CurMsg.HandId:0x%x\r\n", __FUNCTION__, __LINE__,CurMsg.HandType,CurMsg.HandId);
    							run_reply_d207(&CurMsg);
    						break;
    						case 0x8:
    							xil_printf("%s %d  CurMsg.HandType:0x%x CurMsg.HandId:0x%x\r\n", __FUNCTION__, __LINE__,CurMsg.HandType,CurMsg.HandId);
    							run_reply_d208(&CurMsg);
    						break;
    						default:
    						break;
    					}
    					break;

    				default:
    					break;
			}

//			ret = f_mount (NULL, "", 1);
//			if (ret != FR_OK)
//			{
//				xil_printf("f_mount  Failed! ret=%d\n", ret);
//				return 0;
//			}
    }
#endif  //recv


#if 0  //fs test

	#if 1//format the filesysterm
    	ret = f_mkfs(
    		" ",	/* Logical drive number */
			0,			/* Format option  FM_EXFAT*/
			Buff,			/* Pointer to working buffer (null: use heap memory) */
			sizeof Buff			/* Size of working buffer [byte] */
    		);
    	if (ret != FR_OK) {
    		xil_printf("f_mkfs  Failed! ret=%d\n", ret);
    		return 0;
    		}
	#endif//format the filesysterm

	#if 1    //f_mount the filesysterm
    	ret = f_mount (
   		&fs,			/* Pointer to the filesystem object (NULL:unmount)*/
		" ",	/* Logical drive number to be mounted/unmounted */
   		1			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
    	);
    	if (ret != FR_OK) {
	    xil_printf("f_mount  Failed! ret=%d\n", ret);
   		return 0;
    	}
    	xil_printf("f_mount  ok!......\n");
	#endif   //f_mount the filesysterm

	#if 1  //f_mkdir
	ret =f_mkdir("payload");
	   if (ret != FR_OK) {
	    xil_printf("f_mkdir  Failed! ret=%d\n", ret);
   		return -1;
	   }
	   xil_printf("f_mkdir ok!....... ");
	#endif//f_mkdir

	#if 1   //f_open&write
	   ret =f_open(&fnew, "payload/wfeng.txt", FA_CREATE_ALWAYS | FA_WRITE );
	   if (ret != FR_OK) {
	    xil_printf("f_open  Failed! ret=%d\n", ret);
   		return -1;
	   }
	   xil_printf("f_open ok!..........\n");
	   
	   xil_printf("START f_WRITE 10MB DATA!.........\n");
	   memset((BYTE *)(0x80000000),7,1048576*10);
	   ret =f_write(&fnew,(BYTE *)(0x80000000),1048576*10,&fnum);
	   if (ret != FR_OK) {
	    xil_printf("f_write  Failed! ret=%d\n", ret);
   		return -1;
	   }
	   xil_printf("END f_write 10MB DATA!,fnum = %d",fnum);

	    f_close(&fnew);
	#endif //f_open&write

#endif  //fs test

    cleanup_platform();
    return 0;

}
#endif
void DiskInit()
{
	uint8_t   i;
	//xil_printf("Configure Timeout Value in second (HEX-0x?): \0");
	//mygets(input_string);
	//timeout_sec = strtoul(input_string, NULL, 0);
	timeout_sec = 1;
    xil_printf("NVMe Host IP Core Initialization Starts....\r\n");

    for(i=0;i<NHC_NUM;i++)
    {
		if(nhc_init(i,timeout_sec, freq_MHz) == 0x1) // 250MHz
		{
			xil_printf("NVMe Host IP Core #%1d Initialization Completes.\r\n",i);
		}
		else
		{
			xil_printf("NVMe Host IP Core #%1d Initialization Failed!\r\n",i);
		}
    }
    // ---------------------------------------------------------------------------
    // NHC Queue Configuration: 64-nodes depth and User mode
    // ---------------------------------------------------------------------------
    xil_printf("User Command Queue Configuration Starts....\r\n");
    for(i=0;i<NHC_NUM;i++)
    {
		if(nhc_queue_init(i,63, 0) == 0x1)
		{
			xil_printf("Core #%1d User Command Queue Configuration Completes.\r\n",i);
		}
		else
		{
			xil_printf("Core #%1d User Command Queue Configuration Failed!\r\n",i);
		}
    }
    // ---------------------------------------------------------------------------
    // NHC Startup
    // ---------------------------------------------------------------------------
    xil_printf("NHC Startup Starts(Identification, I/O Queue, ...)....\r\n");
    for(i=0;i<NHC_NUM;i++)
    {
		if(adm_startup(i) == 0x2)
		{
			xil_printf("NHC%1d Startup Completes.\r\n",i);
		}
		else
		{
			xil_printf("NHC%1d Startup Failed!\r\n",i);
		}
    }

    init_done = 0xFF;
    for(i=0;i<NHC_NUM;i++)
    {
    	io_monitor_enable(i);
    }

}

